<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Finger Swipe Particle Shapes</title>

  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    video { display: none; }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 320px;
      height: 240px;
      z-index: 10;
      pointer-events: none;
    }

    #shape-ui {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      font-size: 32px;
      user-select: none;
      opacity: 0.9;
      z-index: 20;
      color: #fff;
      font-family: system-ui, sans-serif;
    }

    .shape-icon {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      transition: 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
    }

    .shape-icon.active {
      background: rgba(255,255,255,0.9);
      color: #000;
      transform: scale(1.15);
      box-shadow: 0 0 12px rgba(255,255,255,0.6);
    }

    .shape-icon-label {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      opacity: 0.8;
      z-index: 20;
    }
  </style>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>

<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="overlay"></canvas>

  <!-- UI -->
  <div id="shape-ui">
    <div class="shape-icon" data-id="0">âšª</div>
    <div class="shape-icon" data-id="1">â¤ï¸</div>
    <div class="shape-icon" data-id="2">ğŸŒ¸</div>
    <div class="shape-icon" data-id="3">ğŸª</div>
    <div class="shape-icon" data-id="4">ğŸ†</div>
    <div class="shape-icon" data-id="5">ğŸ–¼ï¸</div>
  </div>

  <div class="shape-icon-label">
    ç”¨é£ŸæŒ‡æ»‘å‹•åˆ‡æ›åœ–æ¡ˆ Â· æåˆæ”¹è®Šé¡è‰² Â· å¼µé–‹æ”¹è®Šæ•£ä½ˆ
  </div>

  <!-- æ”¾åœ¨ GitHub ä¸Šã€èˆ‡æ­¤æª”åŒè³‡æ–™å¤¾çš„åœ–ç‰‡ï¼Œä¾‹å¦‚ google-translate.png -->
  <img id="shapeImage" src="xxxx.png" style="display:none;">

<script>
/* ============================================================
   Three.js åŸºæœ¬å ´æ™¯
============================================================ */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.set(0, 0, 5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ============================================================
   Overlay Canvasï¼ˆé¡é ­ + æ‰‹æŒ‡é»ï¼‰
============================================================ */
const overlay = document.getElementById("overlay");
const ctx = overlay.getContext("2d");
overlay.width = 640;
overlay.height = 480;

const video = document.getElementById("video");

function drawHandOverlay(landmarks) {
  ctx.clearRect(0, 0, overlay.width, overlay.height);

  // é¡åƒé¡é ­
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(video, -overlay.width, 0, overlay.width, overlay.height);
  ctx.restore();

  if (!landmarks) return;

  ctx.fillStyle = "rgba(0,255,0,0.9)";
  const finger = landmarks[8];

  const x = (1 - finger.x) * overlay.width;
  const y = finger.y * overlay.height;

  ctx.beginPath();
  ctx.arc(x, y, 8, 0, Math.PI * 2);
  ctx.fill();
}

/* ============================================================
   ç²’å­åˆå§‹åŒ–
============================================================ */
const count = 20000;
const positions = new Float32Array(count * 3);
const colors = new Float32Array(count * 3);
const targetPositions = new Float32Array(count * 3);

for (let i = 0; i < count; i++) {
  const i3 = i * 3;
  positions[i3]   = (Math.random() - 0.5) * 4;
  positions[i3+1] = (Math.random() - 0.5) * 4;
  positions[i3+2] = (Math.random() - 0.5) * 4;

  colors[i3]   = Math.random();
  colors[i3+1] = Math.random();
  colors[i3+2] = Math.random();
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
  size: 0.05,
  vertexColors: true,
  transparent: true,
  depthWrite: false,
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ============================================================
   åœ–ç‰‡è½‰ç²’å­å½¢ç‹€ï¼ˆä½ç½® + é¡è‰²ï¼‰
============================================================ */
let imageShapePoints = null; // [{pos: Vector3, color:{r,g,b}}, ...]

function shapeFromImage(img, count, callback) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  canvas.width = 200;
  canvas.height = 200;

  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  const points = [];

  for (let y = 0; y < canvas.height; y += 3) {
    for (let x = 0; x < canvas.width; x += 3) {
      const i = (y * canvas.width + x) * 4;
      const r = data[i] / 255;
      const g = data[i + 1] / 255;
      const b = data[i + 2] / 255;
      const a = data[i + 3];

      if (a > 128) {
        const nx = (x / canvas.width) * 2 - 1;
        const ny = -(y / canvas.height) * 2 + 1;

        points.push({
          pos: new THREE.Vector3(nx, ny, 0),
          color: { r, g, b }
        });
      }
    }
  }

  const result = [];
  for (let i = 0; i < count; i++) {
    const p = points[Math.floor(Math.random() * points.length)];
    result.push({
      pos: p.pos.clone(),
      color: { r: p.color.r, g: p.color.g, b: p.color.b }
    });
  }

  callback(result);
}

const img = document.getElementById("shapeImage");
img.onload = () => {
  shapeFromImage(img, count, (pts) => {
    imageShapePoints = pts;
  });
};

/* ============================================================
   ç²’å­å½¢ç‹€æ¨¡æ¿
============================================================ */
function shapeSphere(i, count) {
  const u = i / count;
  const theta = Math.acos(2 * u - 1);
  const phi = Math.random() * Math.PI * 2;
  const r = 1.0;
  return new THREE.Vector3(
    r * Math.sin(theta) * Math.cos(phi),
    r * Math.cos(theta),
    r * Math.sin(theta) * Math.sin(phi)
  );
}

function shapeHeart(i, count) {
  const t = (i / count) * Math.PI * 2;
  const r = 0.5;
  const x = r * 16 * Math.pow(Math.sin(t), 3);
  const y =
    r * (13 * Math.cos(t) -
    5 * Math.cos(2 * t) -
    2 * Math.cos(3 * t) -
    Math.cos(4 * t));
  const z = (Math.random() - 0.5) * 0.2;
  return new THREE.Vector3(x * 0.05, y * 0.05, z);
}

function shapeFlower(i, count) {
  const petals = 5;
  const t = (i / count) * Math.PI * 2;
  const r = 0.8 + 0.2 * Math.sin(petals * t);
  return new THREE.Vector3(
    r * Math.cos(t),
    r * Math.sin(t),
    (Math.random() - 0.5) * 0.3
  );
}

function shapeSaturn(i, count) {
  if (i < count * 0.7) return shapeSphere(i, count * 0.7);
  const t = Math.random() * Math.PI * 2;
  return new THREE.Vector3(
    1.5 * Math.cos(t),
    (Math.random() - 0.5) * 0.1,
    1.5 * Math.sin(t)
  );
}

function shapeFireworks(i, count) {
  const t = Math.random() * Math.PI * 2;
  const u = Math.random() * 2 - 1;
  const theta = Math.acos(u);
  const r = 0.2 + Math.random() * 2.0;
  return new THREE.Vector3(
    r * Math.sin(theta) * Math.cos(t),
    r * Math.cos(theta),
    r * Math.sin(theta) * Math.sin(t)
  );
}

function updateShapeTargets(type) {
  for (let i = 0; i < count; i++) {
    let p;

    switch (type) {
      case 0: p = shapeSphere(i, count); break;
      case 1: p = shapeHeart(i, count); break;
      case 2: p = shapeFlower(i, count); break;
      case 3: p = shapeSaturn(i, count); break;
      case 4: p = shapeFireworks(i, count); break;
      case 5:
        if (imageShapePoints) {
          p = imageShapePoints[i].pos;
        } else {
          p = new THREE.Vector3(0, 0, 0);
        }
        break;
    }

    const i3 = i * 3;
    targetPositions[i3]   = p.x;
    targetPositions[i3+1] = p.y;
    targetPositions[i3+2] = p.z;
  }
}

/* ============================================================
   UI æ›´æ–°
============================================================ */
function updateShapeUI(activeId) {
  document.querySelectorAll(".shape-icon").forEach((el) => {
    el.classList.toggle("active", Number(el.dataset.id) === activeId);
  });
}

/* ============================================================
   æ‰‹æŒ‡æ»‘å‹•åµæ¸¬ï¼ˆç©©å®šç‰ˆï¼šä¸é€£è·³ã€ä¸å›å½ˆï¼‰
============================================================ */
let lastFingerX = null;
let swipeLocked = false;
let neutralFrames = 0;

function detectFingerSwipe(x) {
  if (lastFingerX === null) {
    lastFingerX = x;
    return;
  }

  const dx = x - lastFingerX;
  lastFingerX = x;

  // æ‰‹æŒ‡æ¥è¿‘åœæ­¢ â†’ ç´¯ç©ä¸­ç«‹å¹€æ•¸ï¼Œè¶³å¤ å¾Œè§£é–
  if (Math.abs(dx) < 0.01) {
    neutralFrames++;
    if (neutralFrames > 5) {
      swipeLocked = false;
      neutralFrames = 0;
    }
    return;
  }

  neutralFrames = 0;

  if (swipeLocked) return;

  // æ‰‹æŒ‡å¾€å³æ»‘ï¼ˆé¡åƒå¾Œ x å¢åŠ ï¼‰
  if (dx > 0.05) {
    controls.shapeType = (controls.shapeType + 1) % 6;
    swipeLocked = true;
    return;
  }

  // æ‰‹æŒ‡å¾€å·¦æ»‘
  if (dx < -0.05) {
    controls.shapeType = (controls.shapeType - 1 + 6) % 6;
    swipeLocked = true;
    return;
  }
}

/* ============================================================
   æ‰‹å‹¢æ§åˆ¶æ•´åˆï¼ˆåªç”¨é£ŸæŒ‡ï¼‰
============================================================ */
const controls = {
  spread: 1.0,
  colorMode: 0,
  shapeType: 0,
  handX: 0,
};

function updateControlsFromHand(landmarks) {
  if (!landmarks) return;

  const finger = landmarks[8];
  const x = 1 - finger.x; // é¡åƒå¾Œçš„ X

  // æ»‘å‹•æ„Ÿï¼šæ‰‹æŒ‡å·¦å³ä½ç½® â†’ ç²’å­æ—‹è½‰åç§»
  const centeredX = (x - 0.5) * 2;
  controls.handX += (centeredX - controls.handX) * 0.25;

  // åˆ‡æ›åœ–æ¡ˆ
  detectFingerSwipe(x);

  // æåˆæ§åˆ¶é¡è‰²
  const pinch = Math.hypot(
    landmarks[4].x - landmarks[8].x,
    landmarks[4].y - landmarks[8].y
  );

  if (pinch < 0.03) controls.colorMode = 0;
  else if (pinch < 0.07) controls.colorMode = 1;
  else controls.colorMode = 2;

  // æ‰‹æŒå¼µé–‹æ§åˆ¶æ•£ä½ˆ
  const palmWidth = Math.hypot(
    landmarks[1].x - landmarks[17].x,
    landmarks[1].y - landmarks[17].y
  );
  controls.spread = THREE.MathUtils.clamp(palmWidth * 6, 0.3, 3.0);
}

/* ============================================================
   MediaPipe Hands
============================================================ */
let latestHand = null;

navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
  video.srcObject = stream;
});

const hands = new Hands({
  locateFile: (file) =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7,
});

hands.onResults((results) => {
  latestHand =
    results.multiHandLandmarks && results.multiHandLandmarks.length > 0
      ? results.multiHandLandmarks[0]
      : null;

  drawHandOverlay(latestHand);
});

const cameraMP = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 640,
  height: 480,
});
cameraMP.start();

/* ============================================================
   å‹•ç•« Loop
============================================================ */
const clock = new THREE.Clock();
let lastShape = -1;
let baseRotationY = 0;

updateShapeTargets(0);
updateShapeUI(0);

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  if (latestHand) updateControlsFromHand(latestHand);

  if (controls.shapeType !== lastShape) {
    updateShapeTargets(controls.shapeType);
    updateShapeUI(controls.shapeType);
    lastShape = controls.shapeType;
  }

  const pos = geometry.getAttribute("position").array;
  const col = geometry.getAttribute("color").array;

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;

    const tx = targetPositions[i3]   * controls.spread;
    const ty = targetPositions[i3+1] * controls.spread;
    const tz = targetPositions[i3+2] * controls.spread;

    pos[i3]   += (tx - pos[i3])   * 0.1;
    pos[i3+1] += (ty - pos[i3+1]) * 0.1;
    pos[i3+2] += (tz - pos[i3+2]) * 0.1;

    let r, g, b;

    // åœ–ç‰‡æ¨¡å¼ï¼šä½¿ç”¨åœ–ç‰‡åƒç´ é¡è‰²
    if (controls.shapeType === 5 && imageShapePoints) {
      const cImg = imageShapePoints[i].color;
      r = cImg.r;
      g = cImg.g;
      b = cImg.b;
    } else {
      // å…¶å®ƒæ¨¡å¼ï¼šä»ç„¶ä¿ç•™ä¸‰ç¨®é¡è‰²æ¨¡å¼
      if (controls.colorMode === 0) {
        r = 0.2; g = 0.7; b = 1.0;
      } else if (controls.colorMode === 1) {
        r = 1.0; g = 0.6; b = 0.2;
      } else {
        const h = (i / count + clock.elapsedTime * 0.1) % 1;
        const c = new THREE.Color().setHSL(h, 0.7, 0.5);
        r = c.r; g = c.g; b = c.b;
      }
    }

    col[i3]   += (r - col[i3])   * 0.2;
    col[i3+1] += (g - col[i3+1]) * 0.2;
    col[i3+2] += (b - col[i3+2]) * 0.2;
  }

  geometry.getAttribute("position").needsUpdate = true;
  geometry.getAttribute("color").needsUpdate = true;

  baseRotationY += dt * 0.2;
  particles.rotation.y = baseRotationY + controls.handX * 0.6;

  renderer.render(scene, camera);
}

animate();
</script>

</body>
</html>
