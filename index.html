<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Hand Finger Swipe Particles</title>

  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    video { display: none; }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 320px;
      height: 240px;
      z-index: 10;
      pointer-events: none;
    }

    #shape-ui {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      font-size: 32px;
      user-select: none;
      opacity: 0.9;
      z-index: 20;
      color: #fff;
      font-family: system-ui, sans-serif;
    }

    .shape-icon {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      transition: 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
    }

    .shape-icon.active {
      background: rgba(255,255,255,0.9);
      color: #000;
      transform: scale(1.15);
      box-shadow: 0 0 12px rgba(255,255,255,0.6);
    }

    .shape-icon-label {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      opacity: 0.8;
      z-index: 20;
    }
  </style>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>

<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="overlay"></canvas>

  <div id="shape-ui">
    <div class="shape-icon" data-id="0">âšª</div>
    <div class="shape-icon" data-id="1">â¤ï¸</div>
    <div class="shape-icon" data-id="2">ğŸŒ¸</div>
    <div class="shape-icon" data-id="3">ğŸª</div>
    <div class="shape-icon" data-id="4">ğŸ†</div>
  </div>

  <div class="shape-icon-label">ç”¨ã€Œé£ŸæŒ‡æ»‘å‹•ã€åˆ‡æ›åœ–æ¡ˆ Â· æåˆæ”¹è®Šé¡è‰² Â· å¼µé–‹æ”¹è®Šæ•£ä½ˆ</div>

<script>
/* ============================================================
   Three.js åŸºæœ¬å ´æ™¯
============================================================ */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.set(0, 0, 5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ============================================================
   Overlay Canvasï¼ˆé¡é ­ + æ‰‹æŒ‡é»ï¼‰
============================================================ */
const overlay = document.getElementById("overlay");
const ctx = overlay.getContext("2d");
overlay.width = 640;
overlay.height = 480;

const video = document.getElementById("video");

function drawHandOverlay(landmarks) {
  ctx.clearRect(0, 0, overlay.width, overlay.height);

  // é¡åƒé¡é ­
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(video, -overlay.width, 0, overlay.width, overlay.height);
  ctx.restore();

  if (!landmarks) return;

  ctx.fillStyle = "rgba(0,255,0,0.9)";
  const finger = landmarks[8];

  const x = (1 - finger.x) * overlay.width;
  const y = finger.y * overlay.height;

  ctx.beginPath();
  ctx.arc(x, y, 8, 0, Math.PI * 2);
  ctx.fill();
}

/* ============================================================
   ç²’å­åˆå§‹åŒ–
============================================================ */
const count = 5000;
const positions = new Float32Array(count * 3);
const colors = new Float32Array(count * 3);
const targetPositions = new Float32Array(count * 3);

for (let i = 0; i < count; i++) {
  const i3 = i * 3;
  positions[i3] = (Math.random() - 0.5) * 4;
  positions[i3+1] = (Math.random() - 0.5) * 4;
  positions[i3+2] = (Math.random() - 0.5) * 4;

  colors[i3] = Math.random();
  colors[i3+1] = Math.random();
  colors[i3+2] = Math.random();
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
  size: 0.05,
  vertexColors: true,
  transparent: true,
  depthWrite: false,
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ============================================================
   ç²’å­å½¢ç‹€æ¨¡æ¿
============================================================ */
function shapeSphere(i, count) {
  const u = i / count;
  const theta = Math.acos(2 * u - 1);
  const phi = Math.random() * Math.PI * 2;
  const r = 1.0;
  return new THREE.Vector3(
    r * Math.sin(theta) * Math.cos(phi),
    r * Math.cos(theta),
    r * Math.sin(theta) * Math.sin(phi)
  );
}

function shapeHeart(i, count) {
  const t = (i / count) * Math.PI * 2;
  const r = 0.5;
  const x = r * 16 * Math.pow(Math.sin(t), 3);
  const y =
    r * (13 * Math.cos(t) -
    5 * Math.cos(2 * t) -
    2 * Math.cos(3 * t) -
    Math.cos(4 * t));
  const z = (Math.random() - 0.5) * 0.2;
  return new THREE.Vector3(x * 0.05, y * 0.05, z);
}

function shapeFlower(i, count) {
  const petals = 5;
  const t = (i / count) * Math.PI * 2;
  const r = 0.8 + 0.2 * Math.sin(petals * t);
  return new THREE.Vector3(
    r * Math.cos(t),
    r * Math.sin(t),
    (Math.random() - 0.5) * 0.3
  );
}

function shapeSaturn(i, count) {
  if (i < count * 0.7) return shapeSphere(i, count * 0.7);
  const t = Math.random() * Math.PI * 2;
  return new THREE.Vector3(
    1.5 * Math.cos(t),
    (Math.random() - 0.5) * 0.1,
    1.5 * Math.sin(t)
  );
}

function shapeFireworks(i, count) {
  const t = Math.random() * Math.PI * 2;
  const u = Math.random() * 2 - 1;
  const theta = Math.acos(u);
  const r = 0.2 + Math.random() * 2.0;
  return new THREE.Vector3(
    r * Math.sin(theta) * Math.cos(t),
    r * Math.cos(theta),
    r * Math.sin(theta) * Math.sin(t)
  );
}

function updateShapeTargets(type) {
  for (let i = 0; i < count; i++) {
    let p;
    switch (type) {
      case 0: p = shapeSphere(i, count); break;
      case 1: p = shapeHeart(i, count); break;
      case 2: p = shapeFlower(i, count); break;
      case 3: p = shapeSaturn(i, count); break;
      case 4: p = shapeFireworks(i, count); break;
    }
    const i3 = i * 3;
    targetPositions[i3] = p.x;
    targetPositions[i3+1] = p.y;
    targetPositions[i3+2] = p.z;
  }
}

/* ============================================================
   UI æ›´æ–°
============================================================ */
function updateShapeUI(activeId) {
  document.querySelectorAll(".shape-icon").forEach((el) => {
    el.classList.toggle("active", Number(el.dataset.id) === activeId);
  });
}

/* ============================================================
   æ‰‹å‹¢æ§åˆ¶ï¼ˆåªç”¨é£ŸæŒ‡æ»‘å‹•ï¼‰
============================================================ */
const controls = {
  spread: 1.0,
  colorMode: 0,
  shapeType: 0,
  handX: 0,
};

let lastFingerX = null;
let swipeLock = false;
let swipeTimer = 0;

function detectFingerSwipe(x) {
  if (lastFingerX === null) {
    lastFingerX = x;
    return;
  }

  const dx = x - lastFingerX;
  lastFingerX = x;

  // ===== ä¸­ç«‹å€åˆ¤å®šï¼ˆæ‰‹æŒ‡åœæ­¢ï¼‰ =====
  if (Math.abs(dx) < 0.01) {
    neutralFrames++;
    if (neutralFrames > 5) {
      swipeLocked = false;   // å®Œå…¨åœæ­¢å¾Œæ‰è§£é–
      neutralFrames = 0;
    }
    return;
  }

  // æ‰‹æŒ‡é‚„åœ¨å‹• â†’ é‡ç½®ä¸­ç«‹è¨ˆæ•¸
  neutralFrames = 0;

  // å¦‚æœå·²ç¶“è§¸ç™¼éä¸€æ¬¡ â†’ ä¸å†è§¸ç™¼
  if (swipeLocked) return;

  // ===== æ‰‹æŒ‡å¾€å³æ»‘ï¼ˆé¡åƒå¾Œ x å¢åŠ ï¼‰ =====
  if (dx > 0.05) {
    controls.shapeType = (controls.shapeType + 1) % 5;
    swipeLocked = true;
    return;
  }

  // ===== æ‰‹æŒ‡å¾€å·¦æ»‘ =====
  if (dx < -0.05) {
    controls.shapeType = (controls.shapeType - 1 + 5) % 5;
    swipeLocked = true;
    return;
  }
}


function updateControlsFromHand(landmarks) {
  if (!landmarks) return;

  const finger = landmarks[8];
  const x = 1 - finger.x; // é¡åƒå¾Œçš„ X

  // å³æ™‚æ»‘å‹•æ„Ÿ
  const centeredX = (x - 0.5) * 2;
  controls.handX += (centeredX - controls.handX) * 0.25;

  // æ»‘å‹•åˆ‡æ›åœ–æ¡ˆ
  detectFingerSwipe(x);

  // æåˆæ§åˆ¶é¡è‰²
  const pinch = Math.hypot(
    landmarks[4].x - landmarks[8].x,
    landmarks[4].y - landmarks[8].y
  );

  if (pinch < 0.03) controls.colorMode = 0;
  else if (pinch < 0.07) controls.colorMode = 1;
  else controls.colorMode = 2;

  // æ‰‹æŒå¼µé–‹æ§åˆ¶æ•£ä½ˆ
  const palmWidth = Math.hypot(
    landmarks[1].x - landmarks[17].x,
    landmarks[1].y - landmarks[17].y
  );
  controls.spread = THREE.MathUtils.clamp(palmWidth * 6, 0.3, 3.0);
}

/* ============================================================
   MediaPipe Hands
============================================================ */
let latestHand = null;

navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
  video.srcObject = stream;
});

const hands = new Hands({
  locateFile: (file) =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7,
});

hands.onResults((results) => {
  latestHand =
    results.multiHandLandmarks && results.multiHandLandmarks.length > 0
      ? results.multiHandLandmarks[0]
      : null;

  drawHandOverlay(latestHand);
});

const cameraMP = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 640,
  height: 480,
});
cameraMP.start();

/* ============================================================
   å‹•ç•« Loop
============================================================ */
const clock = new THREE.Clock();
let lastShape = -1;
let baseRotationY = 0;

updateShapeTargets(0);
updateShapeUI(0);

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  if (latestHand) updateControlsFromHand(latestHand);

  if (controls.shapeType !== lastShape) {
    updateShapeTargets(controls.shapeType);
    updateShapeUI(controls.shapeType);
    lastShape = controls.shapeType;
  }

  const pos = geometry.getAttribute("position").array;
  const col = geometry.getAttribute("color").array;

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;

    const tx = targetPositions[i3] * controls.spread;
    const ty = targetPositions[i3+1] * controls.spread;
    const tz = targetPositions[i3+2] * controls.spread;

    pos[i3] += (tx - pos[i3]) * 0.1;
    pos[i3+1] += (ty - pos[i3+1]) * 0.1;
    pos[i3+2] += (tz - pos[i3+2]) * 0.1;

    let r, g, b;
    if (controls.colorMode === 0) {
      r = 0.2; g = 0.7; b = 1.0;
    } else if (controls.colorMode === 1) {
      r = 1.0; g = 0.6; b = 0.2;
    } else {
      const h = (i / count + clock.elapsedTime * 0.1) % 1;
      const c = new THREE.Color().setHSL(h, 0.7, 0.5);
      r = c.r; g = c.g; b = c.b;
    }

    col[i3] += (r - col[i3]) * 0.2;
    col[i3+1] += (g - col[i3+1]) * 0.2;
    col[i3+2] += (b - col[i3+2]) * 0.2;
  }

  geometry.getAttribute("position").needsUpdate = true;
  geometry.getAttribute("color").needsUpdate = true;

  baseRotationY += dt * 0.2;
  particles.rotation.y = baseRotationY + controls.handX * 0.6;

  renderer.render(scene, camera);
}

animate();
</script>

</body>
</html>
