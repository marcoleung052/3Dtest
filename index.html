<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Finger Swipe Particle Shapes</title>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }

    video {
      display: none;
    }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 640px;
      height: 480px;
      z-index: 10;
      pointer-events: none;
    }

    #shape-ui {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      font-size: 32px;
      user-select: none;
      opacity: 0.9;
      z-index: 20;
      color: #fff;
      font-family: system-ui, sans-serif;
    }

    .shape-icon {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      transition: 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
    }

    .shape-icon.active {
      background: rgba(255, 255, 255, 0.9);
      color: #000;
      transform: scale(1.15);
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
    }

    .shape-icon-label {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      opacity: 0.8;
      z-index: 20;
    }

    #messageBox {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 40px;
      font-family: system-ui, sans-serif;
      z-index: 50;
      display: none;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
    }
  </style>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>

<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="overlay"></canvas>

  <!-- Shape UI -->
  <div id="shape-ui">
    <div class="shape-icon" data-id="0">âšª</div>
    <div class="shape-icon" data-id="1">â¤ï¸</div>
    <div class="shape-icon" data-id="2">ğŸŒ¸</div>
    <div class="shape-icon" data-id="3">ğŸª</div>
    <div class="shape-icon" data-id="4">ğŸ†</div>
    <div class="shape-icon" data-id="5">ğŸ–¼ï¸</div>
    <div class="shape-icon" data-id="6">ğŸ’¬</div>
    <div class="shape-icon" data-id="7">ğŸ”¤</div>
  </div>

  <div class="shape-icon-label">
    ç”¨é£ŸæŒ‡æ»‘å‹•åˆ‡æ›åœ–æ¡ˆ Â· æåˆæ”¹è®Šé¡è‰² Â· å¼µé–‹æ”¹è®Šæ•£ä½ˆ Â· é»ä¸€ä¸‹åˆ‡æ›é¡è‰² Â· æ‰‹è…•æ—‹è½‰æ—‹è½‰ç²’å­
  </div>

  <div id="messageBox">Hello Marco!</div>

  <!-- ä½ çš„åœ–ç‰‡ï¼ˆæ”¾åœ¨ GitHub åŒè³‡æ–™å¤¾ï¼‰ -->
  <img id="shapeImage" src="xxxx.png" style="display:none;">

  <script>
    /* ============================================================
       Three.js åŸºæœ¬å ´æ™¯
    ============================================================ */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    /* ============================================================
       Overlay Canvasï¼ˆé¡é ­ + æ‰‹æŒ‡é»ï¼‰
    ============================================================ */
    const overlay = document.getElementById("overlay");
    const ctx = overlay.getContext("2d");
    overlay.width = 640;
    overlay.height = 480;

    const video = document.getElementById("video");

    function drawHandOverlay(landmarks) {
      ctx.clearRect(0, 0, overlay.width, overlay.height);

      // é¡åƒé¡é ­
      ctx.save();
      ctx.scale(-1, 1);
      ctx.drawImage(video, -overlay.width, 0, overlay.width, overlay.height);
      ctx.restore();

      if (!landmarks) return;

      ctx.fillStyle = "rgba(0,255,0,0.9)";
      const finger = landmarks[8];

      const x = (1 - finger.x) * overlay.width;
      const y = finger.y * overlay.height;

      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fill();
    }

    /* ============================================================
       ç²’å­åˆå§‹åŒ–
    ============================================================ */
    const count = 5000;
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    const targetPositions = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
      const i3 = i * 3;

      positions[i3]     = (Math.random() - 0.5) * 4;
      positions[i3 + 1] = (Math.random() - 0.5) * 4;
      positions[i3 + 2] = (Math.random() - 0.5) * 4;

      colors[i3]     = Math.random();
      colors[i3 + 1] = Math.random();
      colors[i3 + 2] = Math.random();
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.05,
      vertexColors: true,
      transparent: true,
      depthWrite: false,
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);
        /* ============================================================
       åœ–ç‰‡è½‰ç²’å­å½¢ç‹€ï¼ˆä½ç½® + é¡è‰²ï¼‰
    ============================================================ */
    let imageShapePoints = null;

    function shapeFromImage(img, count, callback) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      canvas.width = 200;
      canvas.height = 200;

      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
      const points = [];

      for (let y = 0; y < canvas.height; y += 3) {
        for (let x = 0; x < canvas.width; x += 3) {
          const i = (y * canvas.width + x) * 4;
          const r = data[i] / 255;
          const g = data[i + 1] / 255;
          const b = data[i + 2] / 255;
          const a = data[i + 3];

          if (a > 128) {
            const nx = (x / canvas.width) * 2 - 1;
            const ny = -(y / canvas.height) * 2 + 1;

            points.push({
              pos: new THREE.Vector3(nx, ny, 0),
              color: { r, g, b }
            });
          }
        }
      }

      const result = [];
      for (let i = 0; i < count; i++) {
        const p = points[Math.floor(Math.random() * points.length)];
        result.push({
          pos: p.pos.clone(),
          color: { r: p.color.r, g: p.color.g, b: p.color.b }
        });
      }

      callback(result);
    }

    const img = document.getElementById("shapeImage");
    img.onload = () => {
      shapeFromImage(img, count, (pts) => {
        imageShapePoints = pts;
      });
    };

    /* ============================================================
       ç²’å­å½¢ç‹€æ¨¡æ¿
    ============================================================ */
    function shapeSphere(i, count) {
      const u = i / count;
      const theta = Math.acos(2 * u - 1);
      const phi = Math.random() * Math.PI * 2;
      const r = 1.0;

      return new THREE.Vector3(
        r * Math.sin(theta) * Math.cos(phi),
        r * Math.cos(theta),
        r * Math.sin(theta) * Math.sin(phi)
      );
    }

    function shapeHeart(i, count) {
      const t = (i / count) * Math.PI * 2;
      const r = 0.5;

      const x = r * 16 * Math.pow(Math.sin(t), 3);
      const y =
        r * (13 * Math.cos(t) -
        5 * Math.cos(2 * t) -
        2 * Math.cos(3 * t) -
        Math.cos(4 * t));

      const z = (Math.random() - 0.5) * 0.2;

      return new THREE.Vector3(x * 0.05, y * 0.05, z);
    }

    function shapeFlower(i, count) {
      const petals = 5;
      const t = (i / count) * Math.PI * 2;
      const r = 0.8 + 0.2 * Math.sin(petals * t);

      return new THREE.Vector3(
        r * Math.cos(t),
        r * Math.sin(t),
        (Math.random() - 0.5) * 0.3
      );
    }

    function shapeSaturn(i, count) {
      if (i < count * 0.7) return shapeSphere(i, count * 0.7);

      const t = Math.random() * Math.PI * 2;

      return new THREE.Vector3(
        1.5 * Math.cos(t),
        (Math.random() - 0.5) * 0.1,
        1.5 * Math.sin(t)
      );
    }

    function shapeFireworks(i, count) {
      const t = Math.random() * Math.PI * 2;
      const u = Math.random() * 2 - 1;
      const theta = Math.acos(u);
      const r = 0.2 + Math.random() * 2.0;

      return new THREE.Vector3(
        r * Math.sin(theta) * Math.cos(t),
        r * Math.cos(theta),
        r * Math.sin(theta) * Math.sin(t)
      );
    }

    function updateShapeTargets(type) {
      for (let i = 0; i < count; i++) {
        let p;

        switch (type) {
          case 0: p = shapeSphere(i, count); break;
          case 1: p = shapeHeart(i, count); break;
          case 2: p = shapeFlower(i, count); break;
          case 3: p = shapeSaturn(i, count); break;
          case 4: p = shapeFireworks(i, count); break;
          case 5:
            p = imageShapePoints
              ? imageShapePoints[i].pos
              : new THREE.Vector3(0, 0, 0);
            break;
          case 6:
            // ğŸ’¬ æ–‡å­—æ¨¡å¼ï¼šç²’å­ä¸éœ€è¦ç›®æ¨™ä½ç½®
            p = new THREE.Vector3(999, 999, 999);
          case 7:
            p = textShapePoints
              ? textShapePoints[i].pos
              : new THREE.Vector3(0, 0, 0);
            break;
        }

        const i3 = i * 3;
        targetPositions[i3]     = p.x;
        targetPositions[i3 + 1] = p.y;
        targetPositions[i3 + 2] = p.z;
      }
    }

    /* ============================================================
       UI æ›´æ–°
    ============================================================ */
    function updateShapeUI(activeId) {
      document.querySelectorAll(".shape-icon").forEach((el) => {
        el.classList.toggle("active", Number(el.dataset.id) === activeId);
      });
    }

    /* ============================================================
       æ‰‹æŒ‡æ»‘å‹•åµæ¸¬ï¼ˆä¸é€£è·³ã€ä¸å›å½ˆï¼‰
    ============================================================ */
    let lastFingerX = null;
    let swipeLocked = false;
    let neutralFrames = 0;

    function detectFingerSwipe(x) {
      if (lastFingerX === null) {
        lastFingerX = x;
        return;
      }

      const dx = x - lastFingerX;
      lastFingerX = x;

      if (Math.abs(dx) < 0.01) {
        neutralFrames++;
        if (neutralFrames > 5) {
          swipeLocked = false;
          neutralFrames = 0;
        }
        return;
      }

      neutralFrames = 0;

      if (swipeLocked) return;

      if (dx > 0.05) {
        controls.shapeType = (controls.shapeType + 1) % 7;
        swipeLocked = true;
        return;
      }

      if (dx < -0.05) {
        controls.shapeType = (controls.shapeType - 1 + 7) % 7;
        swipeLocked = true;
        return;
      }
    }

    /* ============================================================
       é»æ“Šåµæ¸¬ï¼ˆTapï¼‰
    ============================================================ */
    let tapCooldown = 0;
    let wasClose = false;

    function detectTap(landmarks) {
      const d = Math.hypot(
        landmarks[4].x - landmarks[8].x,
        landmarks[4].y - landmarks[8].y
      );

      const isClose = d < 0.03;

      if (isClose && !wasClose && tapCooldown <= 0) {
        controls.colorMode = (controls.colorMode + 1) % 3;
        tapCooldown = 20;
      }

      wasClose = isClose;

      if (tapCooldown > 0) tapCooldown--;
    }

    /* ============================================================
       æ‰‹è…•æ—‹è½‰
    ============================================================ */
    function getHandRotation(landmarks) {
      const dx = landmarks[17].x - landmarks[5].x;
      const dy = landmarks[17].y - landmarks[5].y;
      return Math.atan2(dy, dx);
    }

    /* ============================================================
       æ‰‹å‹¢æ§åˆ¶æ•´åˆ
    ============================================================ */
    const controls = {
      spread: 1.0,
      colorMode: 0,
      shapeType: 0,
      handX: 0,
    };

    function updateControlsFromHand(landmarks) {
      if (!landmarks) return;

      const finger = landmarks[8];
      const x = 1 - finger.x;

      detectFingerSwipe(x);
      detectTap(landmarks);

      const rot = getHandRotation(landmarks);
      controls.handX += (rot - controls.handX) * 0.2;

      const palmWidth = Math.hypot(
        landmarks[1].x - landmarks[17].x,
        landmarks[1].y - landmarks[17].y
      );
      controls.spread = THREE.MathUtils.clamp(palmWidth * 6, 0.3, 3.0);
    }

        /* ============================================================
       MediaPipe Hands
    ============================================================ */
    let latestHand = null;

    navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
      video.srcObject = stream;
    });

    const hands = new Hands({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7,
    });

    hands.onResults((results) => {
      latestHand =
        results.multiHandLandmarks && results.multiHandLandmarks.length > 0
          ? results.multiHandLandmarks[0]
          : null;

      drawHandOverlay(latestHand);
    });

    const cameraMP = new Camera(video, {
      onFrame: async () => {
        await hands.send({ image: video });
      },
      width: 640,
      height: 480,
    });
    cameraMP.start();

    /* ============================================================
       æ–‡å­—è½‰ç²’å­å½¢ç‹€ï¼ˆCanvas â†’ ç²’å­ï¼‰
    ============================================================ */
    let textShapePoints = null;
    
    function shapeFromText(text, count, callback) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
    
      canvas.width = 400;
      canvas.height = 200;
    
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    
      ctx.fillStyle = "white";
      ctx.font = "bold 120px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    
      const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
      const points = [];
    
      for (let y = 0; y < canvas.height; y += 3) {
        for (let x = 0; x < canvas.width; x += 3) {
          const i = (y * canvas.width + x) * 4;
          const a = data[i + 3];
    
          if (a > 128) {
            const nx = (x / canvas.width) * 2 - 1;
            const ny = -(y / canvas.height) * 2 + 1;
    
            points.push({
              pos: new THREE.Vector3(nx, ny, 0),
              color: { r: 1, g: 1, b: 1 }
            });
          }
        }
      }
    
      const result = [];
      for (let i = 0; i < count; i++) {
        const p = points[Math.floor(Math.random() * points.length)];
        result.push({
          pos: p.pos.clone(),
          color: { r: p.color.r, g: p.color.g, b: p.color.b }
        });
      }
    
      callback(result);
    }

    /* ============================================================
       å‹•ç•« Loop
    ============================================================ */
    const clock = new THREE.Clock();
    let lastShape = -1;
    let baseRotationY = 0;
    
    updateShapeTargets(0);
    updateShapeUI(0);
    
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
    
      if (latestHand) updateControlsFromHand(latestHand);
    
      /* åˆ‡æ› shape æ™‚æ›´æ–°ç›®æ¨™ä½ç½® */
      if (controls.shapeType !== lastShape) {
    
        // æ–‡å­—ç²’å­æ¨¡å¼ï¼ˆshapeType = 7ï¼‰
        if (controls.shapeType === 7) {
          shapeFromText("MARCO", count, (pts) => {
            textShapePoints = pts;
            updateShapeTargets(7);
          });
        } else {
          updateShapeTargets(controls.shapeType);
        }
    
        updateShapeUI(controls.shapeType);
    
        // ğŸ’¬ UI æ–‡å­—æ¨¡å¼ï¼ˆshapeType = 6ï¼‰
        if (controls.shapeType === 6) {
          document.getElementById("messageBox").style.display = "block";
          particles.visible = false;
        } else {
          document.getElementById("messageBox").style.display = "none";
          particles.visible = true;
        }
    
        lastShape = controls.shapeType;
      }
    
      /* ç²’å­æ›´æ–°ï¼ˆæ’é™¤ shapeType 6 & 7ï¼‰ */
      if (controls.shapeType !== 6 && controls.shapeType !== 7) {
    
        const pos = geometry.getAttribute("position").array;
        const col = geometry.getAttribute("color").array;
    
        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
    
          const tx = targetPositions[i3]     * controls.spread;
          const ty = targetPositions[i3 + 1] * controls.spread;
          const tz = targetPositions[i3 + 2] * controls.spread;
    
          pos[i3]     += (tx - pos[i3])     * 0.1;
          pos[i3 + 1] += (ty - pos[i3 + 1]) * 0.1;
          pos[i3 + 2] += (tz - pos[i3 + 2]) * 0.1;
    
          let r, g, b;
    
          // åœ–ç‰‡ç²’å­é¡è‰²
          if (controls.shapeType === 5 && imageShapePoints) {
            const cImg = imageShapePoints[i].color;
            r = cImg.r;
            g = cImg.g;
            b = cImg.b;
          }
          // æ–‡å­—ç²’å­é¡è‰²
          else if (controls.shapeType === 7 && textShapePoints) {
            const cTxt = textShapePoints[i].color;
            r = cTxt.r;
            g = cTxt.g;
            b = cTxt.b;
          }
          // å…¶å®ƒæ¨¡å¼
          else {
            if (controls.colorMode === 0) {
              r = 0.2; g = 0.7; b = 1.0;
            } else if (controls.colorMode === 1) {
              r = 1.0; g = 0.6; b = 0.2;
            } else {
              const h = (i / count + clock.elapsedTime * 0.1) % 1;
              const c = new THREE.Color().setHSL(h, 0.7, 0.5);
              r = c.r; g = c.g; b = c.b;
            }
          }
    
          col[i3]     += (r - col[i3])     * 0.2;
          col[i3 + 1] += (g - col[i3 + 1]) * 0.2;
          col[i3 + 2] += (b - col[i3 + 2]) * 0.2;
        }
    
        geometry.getAttribute("position").needsUpdate = true;
        geometry.getAttribute("color").needsUpdate = true;
      }
    
      /* ç²’å­æ—‹è½‰ï¼ˆæ‰‹è…•æ§åˆ¶ï¼‰ */
      baseRotationY += dt * 0.2;
      particles.rotation.y = baseRotationY + controls.handX * 1.2;
    
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
