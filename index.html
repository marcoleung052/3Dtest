<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Hand-Controlled 3D Particles</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    video { display: none; }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 640px;
      height: 480px;
      z-index: 10;
      pointer-events: none;
    }

    #shape-ui {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      font-size: 32px;
      user-select: none;
      opacity: 0.9;
      z-index: 20;
      color: #fff;
      font-family: system-ui, sans-serif;
    }

    .shape-icon {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      transition: 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
    }

    .shape-icon.active {
      background: rgba(255,255,255,0.9);
      color: #000;
      transform: scale(1.15);
      box-shadow: 0 0 12px rgba(255,255,255,0.6);
    }

    .shape-icon-label {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      opacity: 0.8;
      z-index: 20;
    }
  </style>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="overlay"></canvas>

  <div id="shape-ui">
    <div class="shape-icon" data-id="0">âšª</div>
    <div class="shape-icon" data-id="1">â¤ï¸</div>
    <div class="shape-icon" data-id="2">ğŸŒ¸</div>
    <div class="shape-icon" data-id="3">ğŸª</div>
    <div class="shape-icon" data-id="4">ğŸ†</div>
  </div>
  <div class="shape-icon-label">å·¦å³æ»‘å‹•åˆ‡æ›åœ–æ¡ˆ Â· æåˆæ”¹è®Šé¡è‰² Â· å¼µé–‹æ”¹è®Šæ•£ä½ˆ</div>

  <script>
    // =========================
    //  Three.js åŸºæœ¬å ´æ™¯
    // =========================
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // =========================
    //  Overlay Canvasï¼ˆé¡é ­ + é»ï¼‰
    // =========================
    const overlay = document.getElementById("overlay");
    const ctx = overlay.getContext("2d");
    overlay.width = 640;
    overlay.height = 480;

    const video = document.getElementById("video");

    function drawHandOverlay(landmarks) {
      ctx.clearRect(0, 0, overlay.width, overlay.height);

      // é¡åƒé¡é ­ï¼ˆè‡ªæ‹æ„Ÿè¦ºï¼‰
      ctx.save();
      ctx.scale(-1, 1);
      ctx.drawImage(video, -overlay.width, 0, overlay.width, overlay.height);
      ctx.restore();

      if (!landmarks) return;

      ctx.fillStyle = "rgba(0,255,0,0.9)";
      for (let i = 0; i < landmarks.length; i++) {
        // MediaPipe x æ˜¯ 0~1ï¼ˆå·¦â†’å³ï¼‰ï¼Œä½†ç•«é¢å·²é¡åƒï¼Œæ‰€ä»¥è¦ 1 - x
        const x = (1 - landmarks[i].x) * overlay.width;
        const y = landmarks[i].y * overlay.height;
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // =========================
    //  ç²’å­åˆå§‹åŒ–
    // =========================
    const count = 5000;
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    const targetPositions = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
      const i3 = i * 3;
      positions[i3 + 0] = (Math.random() - 0.5) * 4;
      positions[i3 + 1] = (Math.random() - 0.5) * 4;
      positions[i3 + 2] = (Math.random() - 0.5) * 4;

      colors[i3 + 0] = Math.random();
      colors[i3 + 1] = Math.random();
      colors[i3 + 2] = Math.random();
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.05,
      vertexColors: true,
      transparent: true,
      depthWrite: false,
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // =========================
    //  ç²’å­å½¢ç‹€æ¨¡æ¿
    // =========================
    function shapeSphere(i, count) {
      const u = i / count;
      const theta = Math.acos(2 * u - 1);
      const phi = Math.random() * Math.PI * 2;
      const r = 1.0;
      return new THREE.Vector3(
        r * Math.sin(theta) * Math.cos(phi),
        r * Math.cos(theta),
        r * Math.sin(theta) * Math.sin(phi)
      );
    }

    function shapeHeart(i, count) {
      const t = (i / count) * Math.PI * 2;
      const r = 0.5;
      const x = r * 16 * Math.pow(Math.sin(t), 3);
      const y =
        r *
        (13 * Math.cos(t) -
          5 * Math.cos(2 * t) -
          2 * Math.cos(3 * t) -
          Math.cos(4 * t));
      const z = (Math.random() - 0.5) * 0.2;
      return new THREE.Vector3(x * 0.05, y * 0.05, z);
    }

    function shapeFlower(i, count) {
      const petals = 5;
      const t = (i / count) * Math.PI * 2;
      const r = 0.8 + 0.2 * Math.sin(petals * t);
      return new THREE.Vector3(
        r * Math.cos(t),
        r * Math.sin(t),
        (Math.random() - 0.5) * 0.3
      );
    }

    function shapeSaturn(i, count) {
      if (i < count * 0.7) return shapeSphere(i, count * 0.7);
      const t = Math.random() * Math.PI * 2;
      return new THREE.Vector3(
        1.5 * Math.cos(t),
        (Math.random() - 0.5) * 0.1,
        1.5 * Math.sin(t)
      );
    }

    function shapeFireworks(i, count) {
      const t = Math.random() * Math.PI * 2;
      const u = Math.random() * 2 - 1;
      const theta = Math.acos(u);
      const r = 0.2 + Math.random() * 2.0;
      return new THREE.Vector3(
        r * Math.sin(theta) * Math.cos(t),
        r * Math.cos(theta),
        r * Math.sin(theta) * Math.sin(t)
      );
    }

    function updateShapeTargets(type) {
      for (let i = 0; i < count; i++) {
        let p;
        switch (type) {
          case 0: p = shapeSphere(i, count); break;
          case 1: p = shapeHeart(i, count); break;
          case 2: p = shapeFlower(i, count); break;
          case 3: p = shapeSaturn(i, count); break;
          case 4: p = shapeFireworks(i, count); break;
        }
        const i3 = i * 3;
        targetPositions[i3 + 0] = p.x;
        targetPositions[i3 + 1] = p.y;
        targetPositions[i3 + 2] = p.z;
      }
    }

    // =========================
    //  UI æ›´æ–°
    // =========================
    const shapeNames = ["Sphere", "Heart", "Flower", "Saturn", "Fireworks"];
    const labelEl = document.querySelector(".shape-icon-label");

    function updateShapeUI(activeId) {
      document.querySelectorAll(".shape-icon").forEach((el) => {
        el.classList.toggle("active", Number(el.dataset.id) === activeId);
      });
      if (labelEl) {
        labelEl.textContent =
          "å·¦å³æ»‘å‹•åˆ‡æ›åœ–æ¡ˆ Â· ç¾åœ¨æ˜¯ï¼š" + shapeNames[activeId] +
          " Â· æåˆæ”¹è®Šé¡è‰² Â· å¼µé–‹æ”¹è®Šæ•£ä½ˆ";
      }
    }

    // =========================
    //  æ‰‹å‹¢æ§åˆ¶åƒæ•¸
    // =========================
    const controls = {
      spread: 1.0,
      colorMode: 0,
      shapeType: 0,
      handX: 0,          // -1 ~ 1ï¼Œç”¨ä¾†åšæ»‘å‹•æ„Ÿ
    };

    function distance2D(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    // =========================
    //  æ’¥å‹•åµæ¸¬ï¼ˆä¸€æ¬¡æ›ä¸€å€‹åœ–ï¼‰
    // =========================
    let lastX = null;
    let swipeLock = false;
    let swipeTimer = 0;

    function detectSwipe(wristX) {
      if (lastX === null) {
        lastX = wristX;
        return;
      }

      const dx = wristX - lastX;
      lastX = wristX;

      // æ‰‹åœä¸‹ä¾†ä¸€å°æ®µæ™‚é–“ â†’ è§£é–
      if (Math.abs(dx) < 0.01) {
        swipeTimer++;
        if (swipeTimer > 5) {
          swipeLock = false;
          swipeTimer = 0;
        }
        return;
      }

      if (swipeLock) return;

      // æ³¨æ„ï¼šå› ç‚ºç•«é¢å·²é¡åƒï¼Œæ‰€ä»¥é€™è£¡çš„æ–¹å‘æ˜¯ç›´è¦ºçš„ï¼š
      // æ‰‹å¾€å³æ»‘ï¼ˆç•«é¢ä¸Šï¼‰â†’ wristX å¯¦éš›è®Šå° â†’ dx < 0 â†’ ä¸‹ä¸€å€‹åœ–
      if (dx < -0.04) {
        controls.shapeType = (controls.shapeType + 1) % 5;
        swipeLock = true;
        return;
      }

      // æ‰‹å¾€å·¦æ»‘ â†’ wristX è®Šå¤§ â†’ dx > 0 â†’ ä¸Šä¸€å€‹åœ–
      if (dx > 0.04) {
        controls.shapeType = (controls.shapeType - 1 + 5) % 5;
        swipeLock = true;
        return;
      }
    }

    // =========================
    //  æ‰‹å‹¢æ§åˆ¶æ•´åˆ
    // =========================
    function updateControlsFromHand(landmarks) {
      if (!landmarks) return;

      const wrist = landmarks[0];

      // è½‰æˆç•«é¢ä¸Šçš„é¡åƒ Xï¼ˆ0 å·¦ â†’ 1 å³ï¼‰
      const mirroredX = 1 - wrist.x;

      // å³æ™‚ã€Œæ»‘å‹•æ„Ÿã€ï¼šç”¨æ‰‹çš„æ°´å¹³ä½ç½®æ§åˆ¶ä¸€é»é»æ—‹è½‰åç§»
      const centeredX = (mirroredX - 0.5) * 2; // -1 ~ 1
      controls.handX += (centeredX - controls.handX) * 0.2;

      // æ’¥å‹•åµæ¸¬ç”¨åŸå§‹ wrist.xï¼ˆä¸é¡åƒä¹Ÿå¯ä»¥ï¼Œå°é‚è¼¯å·²è™•ç†ï¼‰
      detectSwipe(wrist.x);

      // æ‰‹æŒå¼µé–‹æ§åˆ¶æ•£ä½ˆ
      const palmWidth = distance2D(landmarks[1], landmarks[17]);
      controls.spread = THREE.MathUtils.clamp(palmWidth * 5, 0.3, 3.0);

      // æåˆæ§åˆ¶é¡è‰²æ¨¡å¼
      const indexTip = landmarks[8];
      const thumbTip = landmarks[4];
      const pinch = distance2D(thumbTip, indexTip);

      if (pinch < 0.05) controls.colorMode = 0;
      else if (pinch < 0.1) controls.colorMode = 1;
      else controls.colorMode = 2;
    }

    // =========================
    //  MediaPipe Hands
    // =========================
    let latestHand = null;

    navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
      video.srcObject = stream;
    });

    const hands = new Hands({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7,
    });

    hands.onResults((results) => {
      latestHand =
        results.multiHandLandmarks && results.multiHandLandmarks.length > 0
          ? results.multiHandLandmarks[0]
          : null;

      drawHandOverlay(latestHand);
    });

    const cameraMP = new Camera(video, {
      onFrame: async () => {
        await hands.send({ image: video });
      },
      width: 640,
      height: 480,
    });
    cameraMP.start();

    // =========================
    //  å‹•ç•« Loop
    // =========================
    const clock = new THREE.Clock();
    let lastShape = -1;
    let baseRotationY = 0;

    updateShapeTargets(0);
    updateShapeUI(0);

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      if (latestHand) {
        updateControlsFromHand(latestHand);
      }

      if (controls.shapeType !== lastShape) {
        updateShapeTargets(controls.shapeType);
        updateShapeUI(controls.shapeType);
        lastShape = controls.shapeType;
      }

      const pos = geometry.getAttribute("position").array;
      const col = geometry.getAttribute("color").array;

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;

        const tx = targetPositions[i3 + 0] * controls.spread;
        const ty = targetPositions[i3 + 1] * controls.spread;
        const tz = targetPositions[i3 + 2] * controls.spread;

        pos[i3 + 0] += (tx - pos[i3 + 0]) * 0.1;
        pos[i3 + 1] += (ty - pos[i3 + 1]) * 0.1;
        pos[i3 + 2] += (tz - pos[i3 + 2]) * 0.1;

        let r, g, b;
        if (controls.colorMode === 0) {
          r = 0.2; g = 0.7; b = 1.0;
        } else if (controls.colorMode === 1) {
          r = 1.0; g = 0.6; b = 0.2;
        } else {
          const h = (i / count + clock.elapsedTime * 0.1) % 1;
          const c = new THREE.Color().setHSL(h, 0.7, 0.5);
          r = c.r; g = c.g; b = c.b;
        }

        col[i3 + 0] += (r - col[i3 + 0]) * 0.2;
        col[i3 + 1] += (g - col[i3 + 1]) * 0.2;
        col[i3 + 2] += (b - col[i3 + 2]) * 0.2;
      }

      geometry.getAttribute("position").needsUpdate = true;
      geometry.getAttribute("color").needsUpdate = true;

      baseRotationY += dt * 0.2;
      particles.rotation.y = baseRotationY + controls.handX * 0.6;

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
